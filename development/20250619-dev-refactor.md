✅ Recap

1. Replaced import-time constants with lazy, cached helpers (`whisper_cli()`, `base_model()`), preventing crashes when the binary or model is missing.
2. Delegated whisper-cli discovery to `whisp_cpp_runtime.binary_path()` – supports repo builds, wheel assets, env-vars, and auto-build.
3. Implemented robust base-model resolver with env-var override, repo path, and XDG data dir.
4. Taught `setup.sh` to:
   • Skip compiling if a system binary already exists.  
   • Persist absolute paths for `whisper_binary` and `model_path` in `config.yaml`.

Local tests confirmed that:

• `python -m whisp` starts without errors.  
• `find_whisper_cli()` and `find_base_model()` return correct absolute paths.  
• Environment overrides work.  
• `config.yaml` now stores absolute paths generated by `setup.sh`.

Next recommended (optional) tasks

• Replace remaining uses of the old constants (`WHISPER_CLI`, `BASE_MODEL`) in the codebase/tests with the new helper functions.  
• Add a small CLI command (`whisp doctor`) that calls `whisp.utils.setup_utils.run_all()` to give users a one-stop health check.  
• Consider consolidating all path discovery into a dedicated module (`whisp.locate`) later, to avoid duplication between `paths.py` and `whisp_cpp_runtime`.
